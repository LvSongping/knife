开发环境搭建
========

### 下载并构建开发环境

1. 支持linux和windows两套环境下进行开发。

2. 在你的workspace目录中执行，"git clone https://github.com/chenjw/knife.git knife"，下载源代码。如果没有安装git需要先安装相关工具。

3. 可以直接从源码把java工程和c工程导入到eclipse中。为了兼容linux和windows两套开发环境，需要在eclipse中设置环境变量"JAVA_HOME"到jdk安装目录。

4. 项目使用ant构建，可以在项目根目录使用"ant"，来编译整个开发环境，并生成下载包到"knife/dist"目录中。 需要安装ant。

5. 也可以使用"ant all"来编译的同时自动生成项目文档并自动更新到"http://knife-doc.cloudfoundry.com/"。 前提是需要安装了文档构建工具doxygen，和cloudfoundry操作工具vmc以及它依赖的ruby。

### 目录结构

agent : agent包的源码工程。
build : ant构建时使用的临时目录。
client : client包的源码工程。
core : client和server包共用的部分代码，编译时会分别打包到client和server包中。
dist : ant构建时输出可执行包的目录。
doc : 项目文档和相关配置目录，ant构建时会用于生成项目文档。
lib : 项目依赖的第三方包目录(有些只是测试代码依赖)。
native : 项目依赖的c源码工程，linux版本和windows版本分为两个工程，但共用同一份源码。
server : server包的源码工程。
shell : 构建时用于生成可执行脚本的原始文件。
test : test包的源码工程，用于存放单元测试。

### 依赖的第三方包

client端依赖的第三方包有：

jline-1.0.jar
fastjson-1.1.17.jar
tools.jar

server端依赖的第三方包(会使用独立的classloader加载到目标jvm中)有：

fastjson-1.1.17.jar
misc.javassist-3.9.0.GA
tools.jar


常规的做法一般是先使用jmap命令生成jvm的heapdump，然后把heapdump文件导到本地用相关工具打开。

有时候会因为本地内存不够打不开，也有时候因为要跟踪内存变化不得不多次heapdump，需要多次传输文件。

knife提供了分析这种问题的另一种思路，在运行时直接分析堆内存的结构。

内存泄漏的表现形式往往是某些对象创建后无法回收，因为有其他对象保存着它的引用，这类对象达到一定数量就会造成Outofmemory。

根据诊断的经验，保存这些对象引用的对象往往是同一个或同一类对象，比如list、map等集合类。 因此这个问题就转变为如何搞清楚那些保存其他对象引用数最多的对象是干嘛的。

knife提供了"top thread"命令用于查找堆内存中保存其他对象引用数最多的对象。 可以设置"-n 数量"参数，控制结果集的数量，默认会返回保存引用数做多的那10个对象。

![](top_ref.png)

从结果中看到objectid为13的对象拥有最多的845个其他对象的引用。

接下来可以使用"ref 13"命令来查看是哪些对象引用了了13号对象，这样就可以找出问题出在哪一段逻辑里。

![](top_ref_2.png)

![](top_ref_3.png)

原来这些对象是被AppClassLoader引用了。可以看到是25号对象就是AppClassLoader中的classes属性。 那845个引用就是AppClassLoader对其加载的所有class的引用。

可以看到返回结果中有些名字为"KNIFE_OBJECT_HOLDER"的对象，这是knife在分析时保存的对这些对象的引用，可以忽略(可以使用"clear"命令清除所有这些引用)。

也可以使用"ls -a -n 10 13"命令直接查看13号数组里面的元素都是些什么。为了避免显示输出过多，可以使用"-n 10"参数指定只返回前10个元素。

![](top_ref_4.png)

这样就可以直接判断出数组13中存放的就是已加载的class。
